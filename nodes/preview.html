<script type="text/javascript">

    const COLORS = ['#FF0000', '#FFA500', '#32CD32', '#006400', '#4169E1', '#0000FF', '#FF1493', '#FFC0CB'];

    const getColor = function (index) {
        return COLORS[index % COLORS.length];
    };

    function createSVGElement(type, attributes = {}) {
        const element = document.createElementNS("http://www.w3.org/2000/svg", type);
        Object.keys(attributes).forEach(attr => element.setAttribute(attr, attributes[attr]));
        return element;
    }

    (function () {
        RED.nodes.registerType('preview', {
            category: 'sscma',
            color: "#77C2A4",
            defaults: {
                name: { value: "" },
                active: { value: true },
                pass: { value: false },
                outputs: { value: 0 }
            },
            inputs: 1,
            outputs: 0,
            icon: "font-awesome/fa-video-camera",
            align: 'right',
            palettelabel: "preview",
            label: function () {
                return this.name || "preview";
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            button: {
                toggle: "active",
                visible: function () { return !this.pass; },
                onclick: function () {
                    const label = this.name || "preview";
                    var node = this;
                    $.ajax({
                        url: `image-output/${this.id}/${this.active ? 'enable' : 'disable'}`,
                        type: "POST",
                        success: function (resp, textStatus, xhr) {
                            updateNodeState(node, !node.active);
                            notifyResult(xhr.status, resp, label);
                        },
                        error: handleAjaxError
                    });
                }
            },
            oneditprepare: function () {
                var that = this;
                $('#node-input-width').val(this.width);

                $('#node-input-data').typedInput({
                    default: 'msg',
                    typeField: $("#node-input-dataType"),
                    types: ['msg']
                });
            }
        });

        const latestImages = {};

        var remove = function (nodeid) {
            const $img = document.getElementById("image-output-img-" + nodeid);
            const $group = document.getElementById("image-output-group-" + nodeid);

            if ($img) $img.remove();
            if ($group) $group.remove();
            delete latestImages[nodeid];
        };

        var render = function (id, data, node) {
            const $container = document.getElementById(id);
            if (!$container) return;

            let $img = document.getElementById(`image-output-img-${id}`);
            let $group = document.getElementById(`image-output-group-${id}`);

            if (!$img) {
                $img = createSVGElement('image', {
                    id: `image-output-img-${id}`,
                    x: '0',
                    y: '50'
                });
                $img.addEventListener("click", () => remove(id), { once: false });
                $container.appendChild($img);
            }

            if (!$group) {
                $group = createSVGElement('g', {
                    id: `image-output-group-${id}`,
                    transform: "translate(0, 50)"
                });
                $container.appendChild($group);
            }

            $group.innerHTML = ""; // Clear existing content

            if (data.image) {
                $img.setAttribute('href', `data:image/jpeg;base64,${data.image}`);
            } else if (data?.resolution) {
                const rect = createSVGElement('rect', {
                    x: '0',
                    y: '0',
                    width: data.resolution[0],
                    height: data.resolution[1],
                    fill: 'black'
                });
                const text = createSVGElement('text', {
                    x: 10,
                    y: 20,
                    'font-size': '16',
                    fill: 'yellow',
                    stroke: 'yellow',
                    'font-family': 'Arial'
                });
                text.textContent = "Warning: Please enable the model node's debug mode to display the actual image.";
                $group.appendChild(rect);
                $group.appendChild(text);
            }

            if (data?.lines) {
                data.lines.forEach((line, i) => {
                    const x1 = line[0] * 0.01 * data.resolution[0];
                    const y1 = line[1] * 0.01 * data.resolution[1];
                    const x2 = line[2] * 0.01 * data.resolution[0];
                    const y2 = line[3] * 0.01 * data.resolution[1];
                    const color = getColor(i);
                    const lineElement = createSVGElement('line', {
                        x1, y1, x2, y2,
                        stroke: color,
                        'stroke-width': '1'
                    });
                    $group.appendChild(lineElement);
                });
            }

            if (data?.boxes) {
                data.boxes.forEach((box, i) => {
                    if (box?.length === 6) {
                        const [x, y, w, h, score, tar] = box;
                        const color = getColor(tar);
                        const tarStr = data.labels?.[tar] || tar.toString();
                        const rect = createSVGElement('rect', {
                            x: x - w / 2,
                            y: y - h / 2,
                            width: w,
                            height: h,
                            fill: "none",
                            stroke: color,
                            'stroke-width': '2'
                        });
                        $group.appendChild(rect);

                        const rectText = createSVGElement('rect', {
                            x: x - w / 2,
                            y: y - h / 2 - 14,
                            width: w,
                            height: 16,
                            fill: color,
                            stroke: color,
                            'stroke-width': '2'
                        });
                        $group.appendChild(rectText);

                        const text = createSVGElement('text', {
                            x: x - w / 2 + 5,
                            y: y - h / 2 - 2,
                            'font-size': '14',
                            fill: 'white',
                            stroke: 'white',
                            'font-family': 'Arial'
                        });
                        text.textContent = data?.tracks ? `#${data.tracks[i]}: ${tarStr}(${score})` : `${tarStr}(${score})`;
                        $group.appendChild(text);
                    }
                });
            }

            if (data?.classes) {
                const rectHeight = data.resolution[1] / 16;
                data.classes.forEach(([score, tar], i) => {
                    const tarStr = data.labels?.[tar] || tar.toString();
                    const rectWidth = data.resolution[0] / data.classes.length;
                    const rect = createSVGElement('rect', {
                        x: rectWidth * i,
                        y: 0,
                        width: rectWidth,
                        height: rectHeight,
                        fill: getColor(tar),
                        'fill-opacity': 0.3
                    });
                    $group.appendChild(rect);

                    const text = createSVGElement('text', {
                        x: rectWidth * i,
                        y: data.resolution[1] / 24,
                        'font-size': data.resolution[1] / 24,
                        'font-weight': 'bold',
                        'font-family': 'arial',
                        fill: '#ffffff'
                    });
                    text.textContent = `${tarStr}: ${score}`;
                    $group.appendChild(text);
                });
            }
        };

        var updateNodeState = function (node, newState) {
            const historyEvent = {
                t: 'edit',
                node: node,
                changes: {
                    active: newState
                },
                dirty: node.dirty,
                changed: node.changed
            };
            node.changed = true;
            node.dirty = true;
            RED.nodes.dirty(true);
            RED.history.push(historyEvent);
            RED.view.redraw();
        };

        var notifyResult = function (status, resp, label) {
            if (status == 200) {
                RED.notify(`Successfully ${resp}: ${label}`, "success");
            }
        };

        var handleAjaxError = function (jqXHR, textStatus, errorThrown) {
            let message;
            switch (jqXHR.status) {
                case 404: message = "node not deployed"; break;
                case 0: message = "no response from server"; break;
                default: message = `unexpected error (${textStatus}) ${errorThrown}`;
            }
            RED.notify(`<strong>Error</strong>: ${message}`, "error");
        };

        function subscribe() {
            $.ajax({
                url: `image-output/0/start`,
                type: "POST"
            });
            RED.comms.subscribe('preview', function (event, data) {
                if (data.hasOwnProperty("data")) {
                    latestImages[data.id] = data.data;
                    if (data.data.count % 30 === 0) {
                        $.ajax({
                            url: `image-output/${data.id}/start`,
                            type: "POST"
                        });
                    }
                    render(data.id, data.data, RED.nodes.node(data.id));
                } else {
                    remove(data.id);
                }
            });
        }
        subscribe();


    })();


</script>

<script type="text/html" data-template-name="preview">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Label</label>
        <input type="text" id="node-input-name">
    </div>
    <canvas id="canvas" hidden></canvas>
</script>