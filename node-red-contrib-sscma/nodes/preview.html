<script type="text/javascript">
    // Add fullscreen CSS styles
    const style = document.createElement('style');
    style.textContent = `
        video::-webkit-media-controls-fullscreen-button {
            display: block !important;
        }
        video:fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important;
        }
        video:-webkit-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important;
        }
        video:-moz-full-screen {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important;
        }
        video:-ms-fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            object-fit: contain !important;
        }
    `;
    document.head.appendChild(style);

    const COLORS = [
        "#FF0000", // Red
        "#FF4500", // OrangeRed
        "#FF6347", // Tomato
        "#FF8C00", // DarkOrange
        "#FFA500", // Orange
        "#FFD700", // Gold
        "#32CD32", // LimeGreen
        "#006400", // DarkGreen
        "#4169E1", // RoyalBlue
        "#0000FF", // Blue
        "#1E90FF", // DodgerBlue
        "#00FFFF", // Aqua
        "#00CED1", // DarkTurquoise
        "#20B2AA", // LightSeaGreen
        "#FF1493", // DeepPink
        "#FF69B4", // HotPink
        "#800080", // Purple
        "#8A2BE2", // BlueViolet
        "#9400D3", // DarkViolet
        "#9932CC", // DarkOrchid
        "#BA55D3", // MediumOrchid
        "#FF00FF", // Magenta
        "#C71585", // MediumVioletRed
        "#D2691E", // Chocolate
        "#A52A2A", // Brown
        "#B22222", // FireBrick
        "#8B4513", // SaddleBrown
        "#DEB887", // Burlywood
        "#CD853F", // Peru
        "#F4A460", // SandyBrown
        "#D2B48C", // Tan
        "#F5DEB3", // Wheat
        "#BC8F8F", // RosyBrown
        "#C0C0C0", // Silver
        "#808080", // Gray
        "#696969", // DimGray
        "#A9A9A9", // DarkGray
        "#BDB76B", // DarkKhaki
        "#F5F5DC", // Beige
        "#FFFACD", // LemonChiffon
        "#FFE4B5", // Moccasin
        "#FFDAB9", // PeachPuff
        "#F0E68C", // Khaki
        "#EEE8AA", // PaleGoldenrod
    ];

    const getColor = function (index, opacity = 1) {
        if (opacity < 1 && opacity >= 0) {
            return `rgba(${parseInt(getColor(index).slice(1, 3), 16)}, ${parseInt(getColor(index).slice(3, 5), 16)}, ${parseInt(
                getColor(index).slice(5, 7),
                16,
            )}, ${opacity})`;
        }

        return COLORS[index % COLORS.length];
    };

    function createSVGElement(type, attributes = {}) {
        const element = document.createElementNS("http://www.w3.org/2000/svg", type);
        Object.keys(attributes).forEach((attr) => element.setAttribute(attr, attributes[attr]));
        return element;
    }

    (function () {
        // Global variables for tracking multiple preview instances
        const wsConnections = new Map(); // Map of previewId -> {ws, port, status}
        const latestImages = {};
        // rAF batch rendering
        let rafId = null;
        const pendingRenders = new Map();
        const wsHost = window.location.hostname;
        function scheduleRender(id, data) {
            try {
                pendingRenders.set(id, data);
                if (rafId) return;
                rafId = window.requestAnimationFrame(function () {
                    try {
                        pendingRenders.forEach(function (pdata, pid) {
                            render(pid, pdata);
                        });
                        pendingRenders.clear();
                    } finally {
                        rafId = null;
                    }
                });
            } catch (e) {
                // 兜底直接渲染
                try {
                    render(id, data);
                } catch (err) {}
            }
        }
        // WebSocket management for individual preview nodes
        function startWSForPreview(previewId) {
            const port = determinePortForPreview(previewId);
            const existingConnection = wsConnections.get(previewId);
            
            // Check if connection already exists and is active
            if (existingConnection && existingConnection.ws && 
                (existingConnection.ws.readyState === WebSocket.OPEN || 
                 existingConnection.ws.readyState === WebSocket.CONNECTING)) {
                return;
            }
            
            // Close existing connection if any
            if (existingConnection && existingConnection.ws) {
                try {
                    existingConnection.ws.close();
                } catch (e) {}
                wsConnections.delete(previewId);
            }
            
            try {
                const url = `ws://${wsHost}:${port}`;
                const ws = new WebSocket(url);
                
                const connectionInfo = {
                    ws: ws,
                    port: port,
                    status: "Connecting"
                };
                wsConnections.set(previewId, connectionInfo);
                
                if (port === 8080) {
                    // Port 8080: Handle H.264 video stream
                    const videoId = `preview-video-${previewId}`;
                    const host = document.getElementById(previewId);
                    if (!host) {
                        return;
                    }
                    
                    let $video = document.getElementById(videoId);
                    if (!$video) {
                        let fo = document.getElementById(`preview-fo-${previewId}`);
                        if (!fo) {
                            const vb = (host.getAttribute("viewBox") || "0 0 640 360").split(/\s+/).map(Number);
                            const vw = vb[2] || 640;
                            const vh = vb[3] || 360;
                            const vy = vb[1] || 0;
                            const headerOffset = 50;
                            fo = createSVGElement("foreignObject", {
                                id: `preview-fo-${previewId}`,
                                x: "0",
                                y: String(vy + headerOffset),
                                width: String(vw),
                                height: String(vh), // Remove height restriction
                            });
                            host.appendChild(fo);
                        }
                        const xhtmlNS = "http://www.w3.org/1999/xhtml";
                        const wrapper = document.createElementNS(xhtmlNS, "div");
                        wrapper.setAttribute("allowfullscreen", true);
                        wrapper.setAttribute("webkitallowfullscreen", true);
                        wrapper.setAttribute("mozallowfullscreen", true);
                        try {
                            wrapper.style.width = "100%";
                            wrapper.style.height = "auto";
                            wrapper.style.minHeight = "200px";
                            wrapper.style.display = "flex";
                            wrapper.style.alignItems = "center";
                            wrapper.style.justifyContent = "center";
                        } catch (e) {}
                        $video = document.createElementNS(xhtmlNS, "video");
                        $video.setAttribute("id", videoId);
                        $video.setAttribute("autoplay", true);
                        $video.setAttribute("muted", false);
                        $video.setAttribute("controls", true);
                        $video.setAttribute("allowfullscreen", true);
                        $video.setAttribute("webkitallowfullscreen", true);
                        $video.setAttribute("mozallowfullscreen", true);
                        $video.setAttribute("playsinline", true);
                        
                        // Add double-click fullscreen event
                        $video.addEventListener('dblclick', function() {
                            if ($video.requestFullscreen) {
                                $video.requestFullscreen();
                            } else if ($video.webkitRequestFullscreen) {
                                $video.webkitRequestFullscreen();
                            } else if ($video.mozRequestFullScreen) {
                                $video.mozRequestFullScreen();
                            } else if ($video.msRequestFullscreen) {
                                $video.msRequestFullscreen();
                            }
                        });
                        try {
                            $video.style.width = "100%";
                            $video.style.height = "auto";
                            $video.style.maxHeight = "none";
                            $video.style.objectFit = "contain";
                            $video.style.position = "relative";
                        } catch (e) {}
                        wrapper.appendChild($video);
                        fo.appendChild(wrapper);
                    }
                    
                    loadJMuxer(function () {
                        if (!jmuxers.has(previewId)) {
                            const jm = new JMuxer({
                                node: videoId,
                                mode: "video",
                                flushingTime: 50,
                                fps: 30,
                                debug: false,
                                onError: function () {
                                    try {
                                        this.reset && this.reset();
                                    } catch (e) {}
                                },
                            });
                            jmuxers.set(previewId, jm);
                        }
                        
                        const jm = jmuxers.get(previewId);
                        try {
                            $video.play().catch(function () {});
                        } catch (e) {}
                        
                        ws.binaryType = "arraybuffer";
                        ws.addEventListener("message", function (ev) {
                            try {
                                const u8 = new Uint8Array(ev.data);
                                if (u8 && u8.length) {
                                    jm && jm.feed({ video: u8, duration: 33 });
                                }
                            } catch (e) {}
                        });
                        ws.addEventListener("open", function () {
                            connectionInfo.status = "Connected";
                        });
                        ws.addEventListener("close", function () {
                            connectionInfo.status = "Disconnected";
                            wsConnections.delete(previewId);
                            // Only reconnect if the preview node is still active
                            if (isPreviewNodeActive(previewId)) {
                                setTimeout(() => startWSForPreview(previewId), 3000);
                            }
                        });
                        ws.addEventListener("error", function (e) {
                            connectionInfo.status = "Error";
                        });
                    });
                    return;
                }
                
                // Port 8090: Handle AI inference results and image data
                ws.binaryType = "arraybuffer";
                ws.addEventListener("open", function () {
                    connectionInfo.status = "Connected";
                });
                ws.addEventListener("close", function () {
                    connectionInfo.status = "Disconnected";
                    wsConnections.delete(previewId);
                    // Only reconnect if the preview node is still active
                    if (isPreviewNodeActive(previewId)) {
                        setTimeout(() => startWSForPreview(previewId), 3000);
                    }
                });
                ws.addEventListener("error", function (e) {
                    connectionInfo.status = "Error";
                });
                ws.addEventListener("message", function (event) {
                    try {
                        const dataBuffer = event.data;
                        let obj = null;
                        if (typeof dataBuffer === "string") {
                            obj = JSON.parse(dataBuffer);
                        } else {
                            const uint8Array = new Uint8Array(dataBuffer);
                            const text = new TextDecoder().decode(uint8Array);
                            obj = JSON.parse(text);
                        }
                        if (obj && obj.hasOwnProperty("data")) {
                            const data = obj.data;
                            latestImages[previewId] = data;
                            scheduleRender(previewId, latestImages[previewId]);
                        } else if (obj && !obj.hasOwnProperty("data")) {
                            removePreview(previewId);
                        }
                    } catch (e) {
                        console.error(e);
                    }
                });
            } catch (e) {
                console.error('Error starting WebSocket for preview:', e);
            }
        }
        
        function stopWSForPreview(previewId) {
            const connectionInfo = wsConnections.get(previewId);
            if (connectionInfo && connectionInfo.ws) {
                try {
                    connectionInfo.ws.close();
                } catch (e) {}
                wsConnections.delete(previewId);
            }
        }
        
        function startAllActivePreviewWS() {
            const activeIds = getActivePreviewIds();
            activeIds.forEach(id => startWSForPreview(id));
        }
        
        function stopAllPreviewWS() {
            wsConnections.forEach((connectionInfo, previewId) => {
                stopWSForPreview(previewId);
            });
        }
        // JMuxer 
        const jmuxers = new Map();
        function loadJMuxer(callback) {
            if (window.JMuxer) {
                callback();
                return;
            }
            const s = document.createElement("script");
            s.src = "/sscma/jmuxer.min.js";
            s.onload = function () {
                callback();
            };
            s.onerror = function () {
                try {
                    s.remove();
                } catch (e) {}
            };
            document.head.appendChild(s);
        }
        function getActivePreviewIds() {
            try {
                const nodes = RED.nodes.filterNodes({ type: "preview" }).filter(function (n) {
                    return !n.d && n.active !== false;
                });
                return nodes.map(n => n.id);
            } catch (e) {
                return [];
            }
        }
        
        function isPreviewNodeActive(previewId) {
            try {
                const node = RED.nodes.node(previewId);
                return node && !node.d && node.active !== false;
            } catch (e) {
                return false;
            }
        }
        
        function getActivePreviewId() {
            const ids = getActivePreviewIds();
            return ids.length > 0 ? ids[0] : null;
        }
        
        function hasDeployedPreview() {
            try {
                return getActivePreviewIds().length > 0;
            } catch (e) {
                return false;
            }
        }

        function getUpstreamTypes(previewId) {
            const types = new Set();
            try {
                const nodeSet = RED.nodes.createCompleteNodeSet(true); // Include wire information
                const preview = nodeSet.find((n) => n && n.id === previewId);
                if (!preview) {
                    return Array.from(types);
                }
                
                const tabId = preview.z;

                // Recursively find all upstream node types
                function findUpstreamNodes(targetId, visited = new Set()) {
                    if (visited.has(targetId)) return;
                    visited.add(targetId);
                    
                    nodeSet.forEach((n) => {
                        if (!n || !Array.isArray(n.wires)) return;
                        if (tabId && n.z !== tabId) return; // Only nodes in same tab
                        
                        for (const arr of n.wires) {
                            if (Array.isArray(arr) && arr.includes(targetId)) {
                                if (n.type) {
                                    types.add(n.type);
                                }
                                // Recursively find further upstream nodes
                                findUpstreamNodes(n.id, visited);
                            }
                        }
                    });
                }
                
                findUpstreamNodes(previewId);
            } catch (e) {
                console.error('Error getting upstream node types:', e);
            }
            return Array.from(types);
        }
        function determinePortForPreview(previewId) {
            const types = getUpstreamTypes(previewId);
            
            // Use port 8090 for AI inference results if model node is upstream
            if (types.includes("model")) {
                return 8090;
            }
            
            // Use port 8080 for H.264 video stream if camera node is upstream
            if (types.includes("camera")) {
                return 8080;
            }
            
            // Default to port 8090
            return 8090;
        }


        RED.nodes.registerType("preview", {
            category: "Vision AI",
            color: "#77C2A4",
            defaults: {
                name: { value: "" },
                active: { value: true },
                pass: { value: false },
                outputs: { value: 0 },
            },
            inputs: 1,
            outputs: 0,
            icon: "font-awesome/fa-video-camera",
            align: "right",
            palettelabel: "preview",
            label: function () {
                return this.name || "preview";
            },
            labelStyle: function () {
                return this.name ? "node_label_italic" : "";
            },
            button: {
                toggle: "active",
                visible: function () {
                    return !this.pass;
                },
                onclick: function () {
                    const node = this;
                    const label = this.name || "preview";
                    const active = node.active;
                    try {
                        if (active) {
                            startWSForPreview(node.id);
                        } else {
                            stopWSForPreview(node.id);
                            removePreview(node.id);
                        }
                    } catch (e) {}
                    updateNodeState(node, active);
                    RED.notify(`Successfully ${active ? "activated" : "deactivated"}: ${label}`, "success");
                },
            },
            oneditprepare: function () {
                $("#node-input-width").val(this.width);

                $("#node-input-data").typedInput({
                    default: "msg",
                    typeField: $("#node-input-dataType"),
                    types: ["msg"],
                });
            },
        });

        const removePreview = function (nodeid) {
            try {
                // Check connection info to determine the port for this specific preview node
                const connectionInfo = wsConnections.get(nodeid);
                const nodePort = connectionInfo ? connectionInfo.port : determinePortForPreview(nodeid);
                
                if (nodePort === 8080) {
                    // Clean up video elements
                    const vid = document.getElementById(`preview-video-${nodeid}`);
                    const fo = document.getElementById(`preview-fo-${nodeid}`);
                    if (vid) vid.remove();
                    if (fo) fo.remove();
                    try {
                        if (jmuxers && jmuxers.has(nodeid)) {
                            const jm = jmuxers.get(nodeid);
                            try {
                                jm && jm.reset && jm.reset();
                            } catch (e) {}
                            jmuxers.delete(nodeid);
                        }
                    } catch (e) {}
                } else {
                    // Clean up image elements (port 8090)
                    const $img = document.getElementById("image-output-img-" + nodeid);
                    const $group = document.getElementById("image-output-group-" + nodeid);

                    if ($img) $img.remove();
                    if ($group) $group.remove();
                    delete latestImages[nodeid];
                }
            } catch (e) {}
        };

        const render = function (id, data) {
            const $container = document.getElementById(id);
            if (!$container) return;
            let $img = document.getElementById(`image-output-img-${id}`);
            if (!$img) {
                $img = createSVGElement("image", {
                    id: `image-output-img-${id}`,
                    x: "0",
                    y: "50",
                });
                $container.appendChild($img);
            }

            let $group = document.getElementById(`image-output-group-${id}`);
            if (!$group) {
                $group = createSVGElement("g", {
                    id: `image-output-group-${id}`,
                    transform: "translate(0, 50)",
                });
                $container.appendChild($group);
            }

            $group.innerHTML = ""; // Clear existing content

            if (data.image) {
                $img.setAttribute("href", `data:image/jpeg;base64,${data.image}`);
            } else if (data?.resolution) {
                const rect = createSVGElement("rect", {
                    x: "0",
                    y: "0",
                    width: data.resolution[0],
                    height: data.resolution[1],
                    fill: "black",
                });
                const text = createSVGElement("text", {
                    x: 10,
                    y: 20,
                    "font-size": "16",
                    fill: "yellow",
                    stroke: "yellow",
                    "font-family": "Arial",
                });
                text.textContent = "Warning: Please enable the model node's debug mode to display the actual image.";
                $group.appendChild(rect);
                $group.appendChild(text);
            }

            if (data?.lines) {
                data.lines.forEach((line, i) => {
                    const x1 = line[0] * 0.01 * data.resolution[0];
                    const y1 = line[1] * 0.01 * data.resolution[1];
                    const x2 = line[2] * 0.01 * data.resolution[0];
                    const y2 = line[3] * 0.01 * data.resolution[1];
                    const color = getColor(i);
                    const lineElement = createSVGElement("line", {
                        x1,
                        y1,
                        x2,
                        y2,
                        stroke: color,
                        "stroke-width": "1",
                    });
                    $group.appendChild(lineElement);
                });
            }

            if (data?.boxes) {
                data.boxes.forEach((box, i) => {
                    if (box?.length === 6) {
                        const [x, y, w, h, score, tar] = box;
                        const color = getColor(tar);
                        const tarStr = data.labels?.[i] ?? `NA-${tar}`;
                        const rect = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2,
                            width: w,
                            height: h,
                            fill: "none",
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rect);

                        const rectText = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2 - 14,
                            width: w,
                            height: 16,
                            fill: color,
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rectText);

                        const text = createSVGElement("text", {
                            x: x - w / 2 + 5,
                            y: y - h / 2 - 2,
                            "font-size": "14",
                            fill: "white",
                            stroke: "white",
                            "font-family": "Arial",
                        });
                        text.textContent = data?.tracks ? `#${data.tracks[i]}: ${tarStr}(${score})` : `${tarStr}(${score})`;
                        $group.appendChild(text);
                    }
                });
            }

            if (data?.classes) {
                const rectHeight = data.resolution[1] / 16;
                data.classes.forEach(([score, tar], i) => {
                    const tarStr = data.labels?.[i] ?? `NA-${tar}`;
                    const rectWidth = data.resolution[0] / data.classes.length;
                    const rect = createSVGElement("rect", {
                        x: rectWidth * i,
                        y: 0,
                        width: rectWidth,
                        height: rectHeight,
                        fill: getColor(tar),
                        "fill-opacity": 0.3,
                    });
                    $group.appendChild(rect);

                    const text = createSVGElement("text", {
                        x: rectWidth * i,
                        y: data.resolution[1] / 24,
                        "font-size": data.resolution[1] / 24,
                        "font-weight": "bold",
                        "font-family": "arial",
                        fill: "#ffffff",
                    });
                    text.textContent = `${tarStr}: ${score}`;
                    $group.appendChild(text);
                });
            }

            if (data?.segments) {
                data.segments.forEach((segment, i) => {
                    const box = segment[0];
                    const polygon = segment[1];
                    let color = getColor(i);
                    let rgba = getColor(i, 0.3);
                    if (box?.length === 6) {
                        const [x, y, w, h, score, tar] = box;
                        color = getColor(tar);
                        rgba = getColor(tar, 0.3);
                        const tarStr = data.labels?.[i] ?? `NA-${tar}`;
                        const rect = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2,
                            width: w,
                            height: h,
                            fill: "none",
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rect);

                        const rectText = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2 - 14,
                            width: w,
                            height: 16,
                            fill: color,
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rectText);

                        const text = createSVGElement("text", {
                            x: x - w / 2 + 5,
                            y: y - h / 2 - 2,
                            "font-size": "14",
                            fill: "white",
                            stroke: "white",
                            "font-family": "Arial",
                        });
                        text.textContent = data?.tracks ? `#${data.tracks[i]}: ${tarStr}(${score})` : `${tarStr}(${score})`;
                        $group.appendChild(text);
                    }
                    function convertToPoints(polygon) {
                        let points = "";
                        for (let i = 0; i < polygon.length; i += 2) {
                            points += `${polygon[i]},${polygon[i + 1]} `;
                        }
                        return points.trim();
                    }

                    // Convert the data array to SVG points format
                    const points = convertToPoints(polygon);

                    const polygonElement = createSVGElement("polygon", {
                        points: points,
                        fill: rgba,
                        stroke: color,
                        "stroke-width": "2",
                    });
                    $group.appendChild(polygonElement);
                });
            }

            if (data?.keypoints) {
                data.keypoints.forEach((keypoint, i) => {
                    const box = keypoint[0];
                    const keypoints = keypoint[1];
                    const points = new Set();
                    if (box?.length === 6) {
                        const [x, y, w, h, score, tar] = box;
                        const color = getColor(tar);
                        const tarStr = data.labels?.[i] ?? `NA-${tar}`;
                        const rect = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2,
                            width: w,
                            height: h,
                            fill: "none",
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rect);

                        const rectText = createSVGElement("rect", {
                            x: x - w / 2,
                            y: y - h / 2 - 14,
                            width: w,
                            height: 16,
                            fill: color,
                            stroke: color,
                            "stroke-width": "2",
                        });
                        $group.appendChild(rectText);

                        const text = createSVGElement("text", {
                            x: x - w / 2 + 5,
                            y: y - h / 2 - 2,
                            "font-size": "14",
                            fill: "white",
                            stroke: "white",
                            "font-family": "Arial",
                        });
                        text.textContent = data?.tracks ? `#${data.tracks[i]}: ${tarStr}(${score})` : `${tarStr}(${score})`;
                        $group.appendChild(text);
                    }

                    for (let j = 0; j < keypoints.length; j += 1) {
                        const point = keypoints[j];
                        const x = point[0];
                        const y = point[1];
                        const target = point[3] ? point[3] : j;
                        // draw if point in the box
                        if (x > box[0] - box[2] / 2 && x < box[0] + box[2] / 2 && y > box[1] - box[3] / 2 && y < box[1] + box[3] / 2) {
                            points.add(target);
                        }
                    }

                    if (keypoints?.length === 17) {
                        // nose to left eye
                        if (points.has(0) && points.has(1)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[0][0],
                                y1: keypoints[0][1],
                                x2: keypoints[1][0],
                                y2: keypoints[1][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // nose to right eye
                        if (points.has(0) && points.has(2)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[0][0],
                                y1: keypoints[0][1],
                                x2: keypoints[2][0],
                                y2: keypoints[2][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left eye to left ear
                        if (points.has(1) && points.has(3)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[1][0],
                                y1: keypoints[1][1],
                                x2: keypoints[3][0],
                                y2: keypoints[3][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right eye to right ear
                        if (points.has(2) && points.has(4)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[2][0],
                                y1: keypoints[2][1],
                                x2: keypoints[4][0],
                                y2: keypoints[4][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left ear to left shoulder
                        if (points.has(3) && points.has(5)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[3][0],
                                y1: keypoints[3][1],
                                x2: keypoints[5][0],
                                y2: keypoints[5][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right ear to right shoulder
                        if (points.has(4) && points.has(6)) {
                            const color = getColor(0);
                            const line = createSVGElement("line", {
                                x1: keypoints[4][0],
                                y1: keypoints[4][1],
                                x2: keypoints[6][0],
                                y2: keypoints[6][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left shoulder to right shoulder
                        if (points.has(5) && points.has(6)) {
                            const color = getColor(1);
                            const line = createSVGElement("line", {
                                x1: keypoints[5][0],
                                y1: keypoints[5][1],
                                x2: keypoints[6][0],
                                y2: keypoints[6][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left shoulder to left hip
                        if (points.has(5) && points.has(11)) {
                            const color = getColor(2);
                            const line = createSVGElement("line", {
                                x1: keypoints[5][0],
                                y1: keypoints[5][1],
                                x2: keypoints[11][0],
                                y2: keypoints[11][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right shoulder to right hip
                        if (points.has(6) && points.has(12)) {
                            const color = getColor(2);
                            const line = createSVGElement("line", {
                                x1: keypoints[6][0],
                                y1: keypoints[6][1],
                                x2: keypoints[12][0],
                                y2: keypoints[12][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left hip to right hip
                        if (points.has(11) && points.has(12)) {
                            const color = getColor(2);
                            const line = createSVGElement("line", {
                                x1: keypoints[11][0],
                                y1: keypoints[11][1],
                                x2: keypoints[12][0],
                                y2: keypoints[12][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left shoulder to left elbow
                        if (points.has(5) && points.has(7)) {
                            const color = getColor(1);
                            const line = createSVGElement("line", {
                                x1: keypoints[5][0],
                                y1: keypoints[5][1],
                                x2: keypoints[7][0],
                                y2: keypoints[7][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left elbow to left wrist
                        if (points.has(7) && points.has(9)) {
                            const color = getColor(1);
                            const line = createSVGElement("line", {
                                x1: keypoints[7][0],
                                y1: keypoints[7][1],
                                x2: keypoints[9][0],
                                y2: keypoints[9][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right shoulder to right elbow
                        if (points.has(6) && points.has(8)) {
                            const color = getColor(6);
                            const line = createSVGElement("line", {
                                x1: keypoints[6][0],
                                y1: keypoints[6][1],
                                x2: keypoints[8][0],
                                y2: keypoints[8][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right elbow to right wrist
                        if (points.has(8) && points.has(10)) {
                            const color = getColor(1);
                            const line = createSVGElement("line", {
                                x1: keypoints[8][0],
                                y1: keypoints[8][1],
                                x2: keypoints[10][0],
                                y2: keypoints[10][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left hip to left knee
                        if (points.has(11) && points.has(13)) {
                            const color = getColor(3);
                            const line = createSVGElement("line", {
                                x1: keypoints[11][0],
                                y1: keypoints[11][1],
                                x2: keypoints[13][0],
                                y2: keypoints[13][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // left knee to left ankle
                        if (points.has(13) && points.has(15)) {
                            const color = getColor(3);
                            const line = createSVGElement("line", {
                                x1: keypoints[13][0],
                                y1: keypoints[13][1],
                                x2: keypoints[15][0],
                                y2: keypoints[15][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right hip to right knee
                        if (points.has(12) && points.has(14)) {
                            const color = getColor(3);
                            const line = createSVGElement("line", {
                                x1: keypoints[12][0],
                                y1: keypoints[12][1],
                                x2: keypoints[14][0],
                                y2: keypoints[14][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                        // right knee to right ankle
                        if (points.has(14) && points.has(16)) {
                            const color = getColor(3);
                            const line = createSVGElement("line", {
                                x1: keypoints[14][0],
                                y1: keypoints[14][1],
                                x2: keypoints[16][0],
                                y2: keypoints[16][1],
                                stroke: color,
                                "stroke-width": "2",
                            });
                            $group.appendChild(line);
                        }
                    }

                    for (let j = 0; j < keypoints.length; j += 1) {
                        const point = keypoints[j];
                        const x = point[0];
                        const y = point[1];
                        const target = point[3] ? point[3] : j;
                        // draw if point in the box
                        if (x > box[0] - box[2] / 2 && x < box[0] + box[2] / 2 && y > box[1] - box[3] / 2 && y < box[1] + box[3] / 2) {
                            const color = getColor(target);
                            const circle = createSVGElement("circle", {
                                cx: x,
                                cy: y,
                                r: 3,
                                stroke: color,
                                "stroke-width": "2",
                                fill: color,
                            });
                            $group.appendChild(circle);
                        }
                    }
                });
            }
        };

        const updateNodeState = function (node, newState) {
            const historyEvent = {
                t: "edit",
                node: node,
                changes: {
                    active: newState,
                },
                dirty: node.dirty,
                changed: node.changed,
            };
            node.changed = true;
            node.dirty = true;
            RED.nodes.dirty(true);
            RED.history.push(historyEvent);
            RED.view.redraw();
        };

        const notifyResult = function () {};

        // Listen for deploy events to manage WebSocket lifecycle
        RED.events.on("deploy", function () {
            // Add delay to ensure nodes are fully deployed
            setTimeout(function () {
                let retryCount = 0;
                const maxRetries = 3;
                
                function tryInitialize() {
                    try {
                        const activeIds = getActivePreviewIds();
                        
                        // Retry if no active nodes found and retries remaining
                        if (activeIds.length === 0 && retryCount < maxRetries) {
                            retryCount++;
                            setTimeout(tryInitialize, 1000);
                            return;
                        }
                        
                        // Clean up old previews
                        activeIds.forEach(id => removePreview(id));
                        
                        // Stop all existing connections
                        stopAllPreviewWS();
                        
                        // Start connections for active previews
                        if (hasDeployedPreview()) {
                            // Give cleanup time to complete
                            setTimeout(() => {
                                startAllActivePreviewWS();
                            }, 300);
                        }
                    } catch (e) {
                        console.error('Error initializing preview:', e);
                        // Retry on error
                        if (retryCount < maxRetries) {
                            retryCount++;
                            setTimeout(tryInitialize, 1000);
                        }
                    }
                }
                
                tryInitialize();
            }, 1000);
        });

        $(document).ready(function () {
            setTimeout(function () {
                if (hasDeployedPreview()) {
                    startAllActivePreviewWS();
                }
            }, 1000);
        });
    })();
</script>

<script type="text/html" data-template-name="preview">
    <div class="form-row">
        <label for="node-input-name">
            <i class="fa fa-tag"></i>
            Label
        </label>
        <input type="text" id="node-input-name" />
    </div>
    <canvas id="canvas" hidden></canvas>
</script>

<script type="text/markdown" data-help-name="preview">
This is the `preview` node for Seeed SenseCraft Model Assistant (e.g. reCamera / Pi camera).

### What it does

-   **Sink node (no outputs)** used to display camera frames and AI inference overlays in the editor UI.
-   Automatically decides data source by upstream wiring:
    -   Upstream contains `camera` → use H.264 (port 8080) and play via JMuxer.
    -   Upstream contains `model` → receive JSON/BASE64 overlays (port 8090) and render in SVG.
-   Redeploy re-initializes the port and reconnects automatically.

### Inputs

-   No wired inputs required for display. Just place `preview` after your nodes to indicate the data flow.
-   Typical wirings:
    -   `camera → preview` (live video preview via 8080)
    -   `camera → model → preview` (AI overlay preview via 8090)

### Configuration

-   **Name**: Optional label shown under the node.
-   Node button: toggle to start/stop preview rendering.

### Behavior details

-   Video (8080): The node injects an HTML `<video>` inside the SVG via `foreignObject` and plays frames using `JMuxer`.
-   Overlays (8090): Draws boxes/segments/keypoints/lines/classes as SVG on top of the base image.
-   If you only see a black canvas with a tip, enable the `Base64 image output` in the `model` node to send images.
-   The JMuxer script is served by this node at `/sscma/jmuxer.min.js` — no extra Node-RED config required.

### Tips

-   If you move between `camera` and `model` pipelines, just redeploy. The node will switch ports automatically.
-   Default device host is `192.168.42.1`. Adjust it in the node source if your device uses a different IP.
-   To clean the view programmatically, call the internal cleanup (the node does this when toggling or redeploying).

### Notes

-   This node is meant for previewing only and does not emit any messages.
-   For saving/streaming, use the `save`/`stream` nodes respectively.
</script>
