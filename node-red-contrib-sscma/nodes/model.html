<style>
    /* CSS Style Optimization */
    #node-input-classes-container {
        margin-top: 5px;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f9f9f9;
    }

    .node-input-class-wrapper {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
        /* Add space between inputs */
    }

    .node-input-class-number {
        width: 20px;
        /* Width for numbering */
        text-align: center;
        font-weight: bold;
        margin-right: 10px;
    }

    .node-input-class {
        flex-grow: 1;
        padding: 5px 10px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 4px;
        transition: border-color 0.3s;
    }

    .node-input-class:focus {
        border-color: #2980b9;
        outline: none;
    }

    .node-input-class:last-of-type {
        margin-bottom: 0;
    }

    #node-input-classes-container-title {
        margin-bottom: 10px;
        font-weight: bold;
        font-size: 14px;
    }

    #node-input-classes-container-hint {
        margin-top: 5px;
        font-size: 12px;
        color: #777;
    }

    .node-input-model-container {
        display: inline-flex;
    }

    .upload-button {
        display: inline-flex;
        align-items: center;
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        background-color: #2980b9;
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: background-color 0.3s;
        width: auto !important;
    }

    .upload-button:hover {
        background-color: #1c5980;
    }

    .upload-button i {
        margin-right: 5px;
    }

    .upload-button + input[type="file"] {
        display: none;
    }

    .preset-button {
        display: inline-flex;
        align-items: center;
        padding: 8px 12px;
        margin-right: 10px;
        border: none;
        border-radius: 4px;
        color: white;
        font-size: 14px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .preset-button-cube {
        background-color: #20c098;
    }
    .preset-button-cloud {
        background-color: #8cc020;
    }

    .preset-button:hover {
        opacity: 0.6;
    }

    .preset-button i {
        margin-right: 5px;
    }

    /* Modal Background */
    #preset-models-modal {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        border-radius: 12px;
        box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        padding: 20px;
        width: 350px;
        max-height: 400px;
        overflow-y: auto;
        z-index: 1001;
        animation: fadeIn 0.3s ease;
    }

    /* Close Button Styling */
    #close-preset-modal {
        display: block;
        width: 100%;
        margin-top: 20px;
        padding: 10px;
        text-align: center;
        background-color: #007bff;
        color: white;
        font-size: 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease;
    }

    #close-preset-modal:hover {
        background-color: #0056b3;
    }

    /* Modal Heading */
    #preset-models-modal h4 {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 20px;
        text-align: center;
        color: #333;
    }

    /* Model List Styling */
    #preset-model-list {
        list-style: none;
        padding-left: 0;
        margin-bottom: 0;
    }

    #preset-model-list li {
        padding: 12px;
        margin-bottom: 10px;
        background-color: #f9f9f9;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.3s ease;
    }

    #preset-model-list li:hover {
        background-color: #f0f0f0;
        transform: scale(1.02);
    }

    #preset-model-list li a {
        text-decoration: none;
        color: #007bff;
        font-weight: bold;
        display: block;
    }

    #preset-model-list li a:hover {
        color: #0056b3;
    }

    #base64-warning {
        display: none;
        margin-left: 180px;
        margin-top: 8px;
        padding: 8px 12px;
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
        font-size: 12px;
        color: #856404;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    #base64-warning i {
        margin-right: 6px;
        color: #f39c12;
    }
</style>

<script type="text/html" data-template-name="model">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i>  Label</span></label>
        <input type="text" id="node-input-name">
    </div>
    <div class="form-row">
        <label for="node-input-client"><i class="fa fa-globe"></i><span> Client</span></label>
        <input type="text" id="node-input-client">
    </div>
    <div class="form-row">
      <label><i class="fa fa-cog"></i> Choose Model From </label>
      <div class="node-input-model-container">
        <button id="btn-preset" class="preset-button preset-button-cube"><i class="fa fa-cube"></i> Device </button>
      </div>
      <div class="node-input-model-container">
        <button id="btn-online" class="preset-button preset-button-cloud"><i class="fa fa-cloud"></i> SenseCraft </button>
      </div>
      <div class="node-input-model-container">
        <label for="upload-file" class="upload-button">
          <i class="fa fa-upload"></i> Upload
        </label>
        <input type="file" id="upload-file" accept=".cvimodel" style="display:none;">
      </div>
    </div>
    <div class="form-row" >
        <label for="node-input-model"><i class="fa fa-file"></i> Model Name</label>
        <input type="text" id="node-input-model" readonly>
    </div>
    <div class="form-row" style="display:none;">
        <label for="node-input-uri"><i class="fa fa-file"></i> URI</label>
        <input type="text" id="node-input-uri">
    </div>
    <div class="form-row">
        <label for="node-input-tscore"><i class="fa fa-sliders"></i> Confidence</label>
        <input type="range" id="node-input-tscore" min="0.01" max="1.00" step="0.01" value="0.45" style="width: 60%;">
        <span id="tscore-value"></span>
    </div>
    <div class="form-row">
        <label for="node-input-tiou"><i class="fa fa-sliders"></i> IOU</label>
        <input type="range" id="node-input-tiou" min="0.01" max="1.00" step="0.01" value="0.25" style="width: 60%;" >
        <span id="tiou-value"></span>
    </div>
    <div class="form-row">
        <label for="node-input-previewResolution" style="width: 160px;"><i class="fa fa-expand"></i> Preview Resolution</label>
        <select id="node-input-previewResolution" style="width: 50%;">
            <option value="auto">Auto</option>
            <option value="640x640">640x640 (Square)</option>
            <option value="1280x720">1280x720 (HD)</option>
            <option value="1920x1080">1920x1080 (Full HD)</option>
        </select>
    </div>
    <div class="form-row">
        <label for="node-input-previewFps" style="width: 160px;"><i class="fa fa-clock-o"></i> Preview FPS</label>
        <select id="node-input-previewFps" style="width: 50%;">
            <option value="5">5 FPS</option>
            <option value="10">10 FPS</option>
            <option value="15">15 FPS</option>
            <option value="30" selected>30 FPS</option>
        </select>
    </div>
    <div class="form-row">
        <label for="node-input-debug" style="width: 160px;"><i class="fa fa-picture-o"></i> Base64 image output</label>
        <input type="checkbox" id="node-input-debug" style="width:auto; margin-top: 0;">
        <div id="base64-warning">
            <i class="fa fa-exclamation-triangle"></i>Warning: Enabling this option may significantly increase system load. Use with caution.
        </div>
    </div>
    <div class="form-row">
        <label for="node-input-trace" style="width: 160px;"><i class="fa fa-toggle-on"></i> Assign ID to Object</label>
        <input type="checkbox" id="node-input-trace" style="width:auto; margin-top: 0;">
    </div>
    <div class="form-row">
        <label for="node-input-counting" style="width: 160px;"><i class="fa fa-hashtag"></i> Count Object</label>
        <input type="checkbox" id="node-input-counting" style="width:auto; margin-top: 0;">
    </div>
    <div class="form-row">
        <label for="node-input-draw" style="width: 160px;"><i class="fa fa-arrows-alt"></i> Draw line for section</label>
        <input type="checkbox" id="node-input-draw" style="width:auto; margin-top: 0;">
        <div id="splitter-row" style="display:none; align-items:center; margin-left: 20px; margin-top: 8px;">
            <canvas id="splitter-canvas" width="100" height="100" style="border: 1px solid black;"></canvas>
            <div id="splitter-legend" style="display: inline-flex; flex-direction: column; gap: 10px; margin-left: 24px;">
                <div style="display:flex; align-items:center; gap:8px;">
                    <div style="width:24px; height:16px; background:#cfe6a8; border:1px solid #ccc;"></div>
                    <span>Area A</span>
                </div>
                <div style="display:flex; align-items:center; gap:8px;">
                    <div style="width:24px; height:16px; background:#f3f5f6; border:1px solid #ccc;"></div>
                    <span>Area B</span>
                </div>
                <button id="btn-reset-line" style="display:inline-flex; align-items:center; gap:6px; background:#c82333; color:#fff; border:none; border-radius:4px; padding:6px 10px; cursor:pointer;">
                    <i class="fa fa-undo"></i>
                    <span>Reset Line</span>
                </button>
            </div>
            <input type="hidden" id="node-input-splitter">
        </div>
    </div>
    <!-- Dynamic class inputs with numbering -->
    <div class="form-row">
        <label for="node-input-classes"><i class="fa fa-list"></i> Classes</label>
        <input type="text" id="node-input-classes" name="classes">
        <div id="node-input-classes-container">
            <div id="node-input-classes-container-title">Class Labels</div>
            <div id="node-input-classes-container-hint">Enter class labels in order.</div>
            <!-- Container for dynamically added inputs -->
        </div>
    </div>
    <div id="preset-models-modal" style="display:none; position: absolute; top: 50px; left: 50%; transform: translateX(-50%); background: white; border: 1px solid #ccc; border-radius: 8px; padding: 10px; width: 300px;">
        <h4>Select a Model</h4>
        <ul id="preset-model-list" style="list-style: none; padding-left: 0;">
            <!-- Dynamic model list will be added here -->
        </ul>
        <button id="close-preset-modal" style="margin-top: 10px; padding: 5px 10px;">Close</button>
    </div>
</script>

<script type="text/javascript">
    async function streamTransferFile(fileUrl) {
        const response = await fetch(fileUrl);
        return response.blob();
    }
    RED.nodes.registerType("model", {
        category: "Vision AI",
        color: "#5A9FD1",
        defaults: {
            name: { value: "" },
            uri: { value: "" },
            model: { value: "" },
            tscore: { value: 0.45 },
            tiou: { value: 0.25 },
            debug: { value: false },
            trace: { value: false },
            counting: { value: false },
            draw: { value: false },
            classes: { value: "" },
            splitter: { value: "0,0,0,0" }, // Array for x1, y1, x2, y2
            previewResolution: { value: "640x640" },
            previewFps: { value: 30 },
            client: { type: "sscma", required: true, label: RED._("sscma") },
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-cube",
        label: function () {
            return this.name || "model";
        },
        oneditprepare: function () {
            const node = this;
            node.modelInfo = "";
            node.modelFile = null;
            node.infoChanged = false;
            const uriInput = document.getElementById("node-input-uri");
            const modelInput = document.getElementById("node-input-model");
            const debugInput = document.getElementById("node-input-debug");
            const traceInput = document.getElementById("node-input-trace");
            const countingInput = document.getElementById("node-input-counting");
            const drawInput = document.getElementById("node-input-draw");
            const splitterCanvas = document.getElementById("splitter-canvas");
            const tscoreInput = document.getElementById("node-input-tscore");
            const tiouInput = document.getElementById("node-input-tiou");
            const tscoreValue = document.getElementById("tscore-value");
            const tiouValue = document.getElementById("tiou-value");
            const splitterInput = document.getElementById("node-input-splitter"); // Hidden input for the array
            const classesContainer = document.getElementById("node-input-classes-container");
            const classesInput = document.getElementById("node-input-classes");
            const uploadFile = document.getElementById("upload-file");
            const clientInput = document.getElementById("node-input-client");
            const presetButton = document.getElementById("btn-preset");
            const modal = document.getElementById("preset-models-modal");
            const presetList = document.getElementById("preset-model-list");
            const closeModalButton = document.getElementById("close-preset-modal");
            const $classesContainer = $("#node-input-classes-container");
            let splitter = [];

            const classes = classesInput.value.split(",").filter(Boolean);
            for (let i = 0; i < classes.length; i++) {
                createClassInput(i, classes[i], true);
            }
            createClassInput(classes.length, "", true);

            function fetchModelInfo() {
                let host = window.location.hostname;
                let port = 80;
                RED.nodes.eachConfig(function (c) {
                    if (c.id === node.client) {
                        host = c.host ? c.host : host;
                        port = c.apiport ? c.apiport : port;
                    }
                });

                if (host == "localhost" || host == "127.0.0.1") {
                    host = window.location.hostname;
                }
                fetch(`http://${host}:${port}/api/deviceMgr/getModelInfo`)
                    .then((response) => response.json())
                    .then((data) => {
                        node.modelInfo = data.data.model_info;
                        const model = JSON.parse(data.data.model_info);
                        modelInput.value = model.model_name;
                        classesInput.value = model.classes.join(",");
                        const classes = classesInput.value.split(",");
                        classesContainer.innerHTML = "";
                        for (let i = 0; i < classes.length; i++) {
                            createClassInput(i, classes[i], true);
                        }
                        createClassInput(classes.length, "", true);
                    });
            }

            fetchModelInfo();

            uploadFile.addEventListener("change", function () {
                const file = this.files[0];
                uriInput.value = "";
                classesInput.value = "";
                modelInput.value = file.name;
                classesContainer.innerHTML = "";
                createClassInput(0, "", true);
                RED.nodes.dirty(true);
            });

            const HANDLE_RADIUS = 4;
            let draggingHandle = null; // 'p1' | 'p2' | 'line' | null
            // 默认：P1 顶部中点，P2 底部中点
            let p1 = { x: Math.round(splitterCanvas.width / 2), y: 0 };
            let p2 = { x: Math.round(splitterCanvas.width / 2), y: splitterCanvas.height };
            // 记录当前扩展线段与线拖拽状态
            let currentExtended = null;
            let lineDragStart = null;
            let lineStartCenter = null;
            let lineDirAtDragStart = null; // 指向 p2->p1 的方向

            function clamp(val, min, max) {
                return Math.max(min, Math.min(max, val));
            }

            function distance(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // 点到线段的最短距离
            function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
                const vx = x2 - x1;
                const vy = y2 - y1;
                const wx = px - x1;
                const wy = py - y1;
                const len2 = vx * vx + vy * vy || 1;
                let t = (wx * vx + wy * vy) / len2;
                t = Math.max(0, Math.min(1, t));
                const projx = x1 + t * vx;
                const projy = y1 + t * vy;
                return distance(px, py, projx, projy);
            }

            function normalize(dx, dy) {
                const len = Math.max(1, Math.sqrt(dx * dx + dy * dy));
                return { x: dx / len, y: dy / len };
            }

            function snapToBorder(x, y, w, h) {
                const distances = [
                    { edge: "left", d: Math.abs(x - 0) },
                    { edge: "right", d: Math.abs(x - w) },
                    { edge: "top", d: Math.abs(y - 0) },
                    { edge: "bottom", d: Math.abs(y - h) },
                ];
                distances.sort((a, b) => a.d - b.d);
                const nearest = distances[0].edge;
                if (nearest === "left") return { x: 0, y: clamp(y, 0, h) };
                if (nearest === "right") return { x: w, y: clamp(y, 0, h) };
                if (nearest === "top") return { x: clamp(x, 0, w), y: 0 };
                return { x: clamp(x, 0, w), y: h };
            }

            function initializeHandlesFromInput() {
                const parts = (splitterInput.value || "").split(",").map(Number);
                if (parts.length === 4 && parts.some((n) => !isNaN(n) && n !== 0)) {
                    // 存储顺序定义为：x1,y1 是 p1（顶部），x2,y2 是 p2（底部）
                    p1 = snapToBorder(
                        clamp(parts[0], 0, splitterCanvas.width),
                        clamp(parts[1], 0, splitterCanvas.height),
                        splitterCanvas.width,
                        splitterCanvas.height,
                    );
                    p2 = snapToBorder(
                        clamp(parts[2], 0, splitterCanvas.width),
                        clamp(parts[3], 0, splitterCanvas.height),
                        splitterCanvas.width,
                        splitterCanvas.height,
                    );
                }
            }

            tscoreValue.innerText = tscoreInput.value;
            tiouValue.innerText = tiouInput.value;

            // Update counting checkbox state based on trace checkbox
            function updateCountingState() {
                countingInput.disabled = !traceInput.checked;
                if (!traceInput.checked) {
                    countingInput.checked = false;
                }
                // Enable draw only when counting is enabled
                drawInput.disabled = !countingInput.checked;
                if (!countingInput.checked) {
                    drawInput.checked = false;
                }
                updateCanvas();
            }

            // Update range slider values
            function updateSliderValue(input, display) {
                display.innerText = input.value;
            }

            // 构造“左侧半平面与画布矩形的交集”多边形
            function buildLeftHalfPlanePolygon(extended, canvasWidth, canvasHeight) {
                const dx = extended.x2 - extended.x1;
                const dy = extended.y2 - extended.y1;
                const isLeft = (q) => dx * (q.y - extended.y1) - dy * (q.x - extended.x1) > 0;

                const corners = [
                    { x: 0, y: 0 },
                    { x: canvasWidth, y: 0 },
                    { x: canvasWidth, y: canvasHeight },
                    { x: 0, y: canvasHeight },
                ];

                // 选取在左侧半平面的四个角
                const pts = corners.filter(isLeft);
                // 加入直线与矩形的交点（extended 已给出）
                pts.push({ x: extended.x1, y: extended.y1 });
                pts.push({ x: extended.x2, y: extended.y2 });

                // 去除可能重复点
                const uniq = [];
                const keySet = new Set();
                for (const pt of pts) {
                    const k = `${Math.round(pt.x)}_${Math.round(pt.y)}`;
                    if (!keySet.has(k)) {
                        keySet.add(k);
                        uniq.push(pt);
                    }
                }

                // 按极角排序为凸多边形
                const cx = uniq.reduce((s, p) => s + p.x, 0) / uniq.length;
                const cy = uniq.reduce((s, p) => s + p.y, 0) / uniq.length;
                uniq.sort((a, b) => Math.atan2(a.y - cy, a.x - cx) - Math.atan2(b.y - cy, b.x - cx));
                return uniq;
            }

            // Update canvas for line drawing
            function updateCanvas() {
                if (!drawInput.checked) {
                    document.getElementById("splitter-row").style.display = "none";
                    return;
                }
                document.getElementById("splitter-row").style.display = "flex";
                const canvasWidth = splitterCanvas.width;
                const canvasHeight = splitterCanvas.height;
                const ctx = splitterCanvas.getContext("2d");
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                // 先填充 B 区背景色
                ctx.fillStyle = "#f3f5f6";
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Extend line to edges in direction p2 -> p1 and store to hidden input
                const extended = extendLineToEdges(p2.x, p2.y, p1.x, p1.y, canvasWidth, canvasHeight);
                currentExtended = extended;
                // 写回隐藏值为原始端点顺序：p1 在前，p2 在后
                splitterInput.value = [Math.round(p1.x), Math.round(p1.y), Math.round(p2.x), Math.round(p2.y)].join(",");

                // 填充 A 区：p2 -> p1 的左侧半平面与矩形的交集
                const poly = buildLeftHalfPlanePolygon(extended, canvasWidth, canvasHeight);
                if (poly.length >= 3) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(poly[0].x, poly[0].y);
                    for (let i = 1; i < poly.length; i++) {
                        ctx.lineTo(poly[i].x, poly[i].y);
                    }
                    ctx.closePath();
                    ctx.clip();
                    ctx.fillStyle = "#cfe6a8";
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                    ctx.restore();
                }

                // Draw outer border
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, canvasWidth, canvasHeight);

                // Draw dividing line
                ctx.beginPath();
                ctx.moveTo(extended.x1, extended.y1);
                ctx.lineTo(extended.x2, extended.y2);
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw draggable handles
                ctx.fillStyle = "#fff";
                ctx.strokeStyle = "#333";
                ctx.lineWidth = 1.5;
                [p1, p2].forEach((pt) => {
                    ctx.beginPath();
                    ctx.arc(pt.x, pt.y, HANDLE_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
            }

            // Extend line to canvas edges，保持方向：从 (x1,y1)=p2 指向 (x2,y2)=p1
            function extendLineToEdges(x1, y1, x2, y2, canvasWidth, canvasHeight) {
                const dirx = x2 - x1;
                const diry = y2 - y1;
                const eps = 1e-6;

                // 垂直或水平退化处理
                if (Math.abs(dirx) < eps && Math.abs(diry) < eps) {
                    return { x1: Math.round(x1), y1: Math.round(y1), x2: Math.round(x2), y2: Math.round(y2) };
                }

                const hits = [];
                // 与 x=0 和 x=canvasWidth 相交
                if (Math.abs(dirx) >= eps) {
                    let t = (0 - x1) / dirx;
                    let y = y1 + t * diry;
                    if (y >= -eps && y <= canvasHeight + eps) hits.push({ t, x: 0, y });
                    t = (canvasWidth - x1) / dirx;
                    y = y1 + t * diry;
                    if (y >= -eps && y <= canvasHeight + eps) hits.push({ t, x: canvasWidth, y });
                }
                // 与 y=0 和 y=canvasHeight 相交
                if (Math.abs(diry) >= eps) {
                    let t = (0 - y1) / diry;
                    let x = x1 + t * dirx;
                    if (x >= -eps && x <= canvasWidth + eps) hits.push({ t, x, y: 0 });
                    t = (canvasHeight - y1) / diry;
                    x = x1 + t * dirx;
                    if (x >= -eps && x <= canvasWidth + eps) hits.push({ t, x, y: canvasHeight });
                }

                // 去重并按 t 排序，取最小和最大 t
                const uniq = [];
                const keySet = new Set();
                for (const h of hits) {
                    const k = `${Math.round(h.x)}_${Math.round(h.y)}`;
                    if (!keySet.has(k)) {
                        keySet.add(k);
                        uniq.push(h);
                    }
                }
                uniq.sort((a, b) => a.t - b.t);

                if (uniq.length >= 2) {
                    const a = uniq[0];
                    const b = uniq[uniq.length - 1];
                    return { x1: Math.round(a.x), y1: Math.round(a.y), x2: Math.round(b.x), y2: Math.round(b.y) };
                }

                // 兜底：如果只得到一个点或异常，退回旧逻辑近似
                if (Math.abs(dirx) < eps) {
                    return { x1: Math.round(x1), y1: 0, x2: Math.round(x2), y2: canvasHeight };
                }
                if (Math.abs(diry) < eps) {
                    return { x1: 0, y1: Math.round(y1), x2: canvasWidth, y2: Math.round(y2) };
                }
                const slope = diry / dirx;
                const intercept = y1 - slope * x1;
                let xStart = 0;
                let yStart = intercept;
                if (yStart < 0 || yStart > canvasHeight) {
                    yStart = yStart < 0 ? 0 : canvasHeight;
                    xStart = (yStart - intercept) / slope;
                }
                let xEnd = canvasWidth;
                let yEnd = slope * xEnd + intercept;
                if (yEnd < 0 || yEnd > canvasHeight) {
                    yEnd = yEnd < 0 ? 0 : canvasHeight;
                    xEnd = (yEnd - intercept) / slope;
                }
                return { x1: Math.round(xStart), y1: Math.round(yStart), x2: Math.round(xEnd), y2: Math.round(yEnd) };
            }

            splitterCanvas.addEventListener("mousedown", function (e) {
                const rect = splitterCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                if (distance(x, y, p1.x, p1.y) <= HANDLE_RADIUS + 3) {
                    draggingHandle = "p1";
                } else if (distance(x, y, p2.x, p2.y) <= HANDLE_RADIUS + 3) {
                    draggingHandle = "p2";
                } else {
                    // 命中线本体则整体拖拽
                    if (
                        currentExtended &&
                        pointToSegmentDistance(x, y, currentExtended.x1, currentExtended.y1, currentExtended.x2, currentExtended.y2) <= HANDLE_RADIUS + 3
                    ) {
                        draggingHandle = "line";
                        lineDragStart = { x, y };
                        lineStartCenter = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
                        lineDirAtDragStart = normalize(p1.x - p2.x, p1.y - p2.y); // 指向 p2->p1
                    } else {
                        draggingHandle = null;
                    }
                }
            });

            splitterCanvas.addEventListener("mousemove", function (e) {
                if (!draggingHandle) return;
                const rect = splitterCanvas.getBoundingClientRect();
                const rawX = e.clientX - rect.left;
                const rawY = e.clientY - rect.top;
                if (draggingHandle === "line") {
                    const dx = rawX - lineDragStart.x;
                    const dy = rawY - lineDragStart.y;
                    const newCenter = { x: lineStartCenter.x + dx, y: lineStartCenter.y + dy };
                    const dir = lineDirAtDragStart || normalize(p1.x - p2.x, p1.y - p2.y);
                    // 使用较长的基准向量，确保扩展后方向稳定（p2->p1）
                    const scale = Math.max(splitterCanvas.width, splitterCanvas.height);
                    const baseP2 = { x: newCenter.x - dir.x * scale, y: newCenter.y - dir.y * scale };
                    const baseP1 = { x: newCenter.x + dir.x * scale, y: newCenter.y + dir.y * scale };
                    const ext = extendLineToEdges(baseP2.x, baseP2.y, baseP1.x, baseP1.y, splitterCanvas.width, splitterCanvas.height);
                    // 保持方向为 p2 -> p1
                    p2 = { x: ext.x1, y: ext.y1 };
                    p1 = { x: ext.x2, y: ext.y2 };
                } else {
                    const snapped = snapToBorder(rawX, rawY, splitterCanvas.width, splitterCanvas.height);
                    if (draggingHandle === "p1") {
                        p1 = snapped;
                    } else if (draggingHandle === "p2") {
                        p2 = snapped;
                    }
                }
                updateCanvas();
            });

            splitterCanvas.addEventListener("mouseup", function () {
                draggingHandle = null;
                lineDragStart = null;
                lineStartCenter = null;
                lineDirAtDragStart = null;
            });
            splitterCanvas.addEventListener("mouseleave", function () {
                draggingHandle = null;
                lineDragStart = null;
                lineStartCenter = null;
                lineDirAtDragStart = null;
            });

            // initialize draw checkbox and canvas visibility
            drawInput.checked = !!node.draw;
            drawInput.disabled = !countingInput.checked;
            initializeHandlesFromInput();
            updateCanvas();

            // Reset line to initial position: p1 top-center, p2 bottom-center
            const resetBtn = document.getElementById("btn-reset-line");
            if (resetBtn) {
                resetBtn.addEventListener("click", function () {
                    p1 = { x: Math.round(splitterCanvas.width / 2), y: 0 };
                    p2 = { x: Math.round(splitterCanvas.width / 2), y: splitterCanvas.height };
                    updateCanvas();
                });
            }

            updateCountingState();

            // Add event listener for Base64 output checkbox
            debugInput.addEventListener("change", function () {
                const warningElement = document.getElementById("base64-warning");
                if (debugInput.checked) {
                    warningElement.style.display = "block";
                } else {
                    warningElement.style.display = "none";
                }
            });

            traceInput.addEventListener("change", updateCountingState);

            countingInput.addEventListener("change", function () {
                if (!countingInput.checked) {
                    drawInput.checked = false;
                }
                drawInput.disabled = !countingInput.checked;
            });

            drawInput.addEventListener("change", function () {
                updateCountingState();
            });

            tscoreInput.addEventListener("input", function () {
                updateSliderValue(tscoreInput, tscoreValue);
            });

            tiouInput.addEventListener("input", function () {
                updateSliderValue(tiouInput, tiouValue);
            });

            classesInput.addEventListener("input", function () {
                node.infoChanged = true;
                classesContainer.innerHTML = "";
                const classes = classesInput.value.split(",");

                for (let i = 0; i < classes.length; i++) {
                    createClassInput(i, classes[i], true);
                }
                createClassInput(classes.length, "", true);
            });

            clientInput.addEventListener("input", function () {
                fetchModelInfo();
            });

            function createClassInput(number, value, editable) {
                // 使用jQuery创建元素并设置属性
                const $wrapper = $("<div>", {
                    class: "node-input-class-wrapper",
                });

                const $numberLabel = $("<div>", {
                    class: "node-input-class-number",
                    text: number,
                });

                const $input = $("<input>", {
                    type: "text",
                    class: "node-input-class",
                    placeholder: "Enter a class label",
                    disabled: !editable,
                    value: value || "",
                    on: {
                        input: handleClassInput,
                    },
                });

                // 使用jQuery的链式操作组装DOM
                $wrapper.append($numberLabel).append($input).appendTo($classesContainer);

                return $input;
            }
            function handleClassInput(event) {
                if (!$classesContainer.length) return;
                // 获取所有class输入框
                const $inputs = $classesContainer.find(".node-input-class");
                if (!$inputs.length) return;
                node.infoChanged = true;
                const values = $inputs
                    .map(function () {
                        return $(this).val().trim();
                    })
                    .get()
                    .filter(Boolean);

                $("#node-input-classes").val(values.join(","));

                const $lastInput = $inputs.last();
                const isLastInput = event.target === $lastInput[0];
                const hasValue = $(event.target).val().trim() !== "";
                if (isLastInput && hasValue) {
                    createClassInput($inputs.length, "", true); // Create a new input with updated numbering
                }
            }

            // Function to fetch model list from the API
            function fetchModelList() {
                let host = window.location.hostname;
                let port = 80;
                RED.nodes.eachConfig(function (c) {
                    if (c.id === node.client) {
                        host = c.host ? c.host : host;
                        port = c.apiport ? c.apiport : port;
                    }
                });

                if (host == "localhost" || host == "127.0.0.1") {
                    host = window.location.hostname;
                }

                fetch(`http://${host}:${port}/api/deviceMgr/getModelList`)
                    .then((response) => response.json())
                    .then((data) => {
                        if (data.code === 0) {
                            const modelList = data.data.list;
                            presetList.innerHTML = ""; // Clear any existing items
                            modelList.forEach((model) => {
                                const listItem = document.createElement("li");
                                listItem.style.marginBottom = "10px";

                                const modelLink = document.createElement("a");
                                modelLink.href = "#";
                                modelLink.innerHTML = model.name; // Display the model name
                                modelLink.addEventListener("click", function () {
                                    // When a model is selected, populate the fields
                                    document.getElementById("node-input-model").value = model.name;
                                    document.getElementById("node-input-uri").value = model.file;

                                    model.model_id = model.id;
                                    model.model_name = model.name;

                                    node.infoChanged = true;

                                    node.modelInfo = JSON.stringify(model);

                                    classesInput.value = model.classes.join(",");
                                    const classes = classesInput.value.split(",");
                                    classesContainer.innerHTML = "";
                                    for (let i = 0; i < classes.length; i++) {
                                        createClassInput(i, classes[i], true);
                                    }
                                    createClassInput(classes.length, "", true);

                                    modal.style.display = "none"; // Close the modal
                                });

                                listItem.appendChild(modelLink);
                                presetList.appendChild(listItem);
                            });
                        } else {
                            console.error("Failed to fetch model list");
                        }
                    })
                    .catch((error) => console.error("Error fetching model list:", error));
            }

            // Show the modal with the list of models
            presetButton.addEventListener("click", function () {
                fetchModelList();
                modal.style.display = "block"; // Show the modal
            });

            const baseUrl = "https://sensecraft.seeed.cc/aiserverapi";
            const $modal = $("#preset-models-modal");
            async function handleModelSelect(model) {
                try {
                    // 更新模型名称
                    node.name = model.name;
                    $("#node-input-model").val(model.name);

                    // 准备并发送应用模型请求
                    const applyModelParams = new URLSearchParams({
                        uniform_type: "36",
                        model_id: model.id,
                    });
                    const applyModelUrl = `${baseUrl}/model/apply_model?${applyModelParams}`;
                    const applyModelResponse = await fetch(applyModelUrl);
                    const {
                        data: { model_snapshot },
                    } = await applyModelResponse.json();

                    // 获取模型文件
                    const file = await streamTransferFile(model_snapshot.arguments.url);
                    node.modelFile = file;
                    $("#node-input-uri").val("");
                    node.modelInfo = JSON.stringify({ ...model_snapshot, model_id: String(model.id) });

                    // 处理类别信息
                    const classes = model_snapshot.classes ?? [];
                    $("#node-input-classes").val(classes.join(","));

                    // 更新类别输入界面
                    updateClassInputs(classes);

                    // 隐藏模态框
                    $modal.hide();
                } catch (error) {
                    console.error("Error:", error);
                }
            }

            // 创建单个模型列表项
            function createModelListItem(model) {
                return $("<li>")
                    .append(
                        $("<a>", {
                            href: "#",
                            text: model.name,
                        }),
                    )
                    .on("click", () => handleModelSelect(model));
            }

            // 更新类别输入界面
            function updateClassInputs(classes) {
                $classesContainer.empty();

                // 为每个类别创建输入框
                classes.forEach((className, index) => {
                    createClassInput(index, className, true);
                });

                // 添加一个空的输入框
                createClassInput(classes.length, "", true);
            }
            async function fetchOnlineModelList() {
                try {
                    const RE_CAMERA_UNIFORM_TYPE = "40";
                    const url = `${baseUrl}/model/list_model`;
                    const params = new URLSearchParams({
                        appid: "131",
                        uniform_type: RE_CAMERA_UNIFORM_TYPE,
                        length: "10",
                        page: "1",
                        get_recommend: "0",
                    });

                    const res = await fetch(`${url}?${params}`);
                    const {
                        data: { list: modelList },
                    } = await res.json();

                    if (!Array.isArray(modelList)) {
                        throw new Error("Model list is not an array");
                    }

                    const $list = $("#preset-model-list");

                    if (!$list.length || !$modal.length) {
                        throw new Error("Required DOM elements not found");
                    }
                    $list.empty().append(modelList.map(createModelListItem));

                    $modal.show();
                } catch (error) {
                    console.error("Error:", error);
                }
            }
            $("#btn-online").click(function () {
                fetchOnlineModelList();
                $("#close-preset-modal").click(function () {
                    $("#preset-models-modal").hide();
                });
            });

            // Close the modal when the "Close" button is clicked
            closeModalButton.addEventListener("click", function () {
                modal.style.display = "none"; // Hide the modal
            });
        },
        oneditsave: function () {
            const node = this;
            const classesInput = document.getElementById("node-input-classes");
            let host = window.location.hostname;
            let port = 80;
            RED.nodes.eachConfig(function (c) {
                if (c.id === node.client) {
                    host = c.host ? c.host : host;
                    port = c.apiport ? c.apiport : port;
                }
            });

            if (host == "localhost" || host == "127.0.0.1") {
                host = window.location.hostname;
            }

            const uploadFile = document.getElementById("upload-file");
            if (uploadFile.files.length > 0) {
                const file = uploadFile.files[0];
                const info = {
                    model_id: "0",
                    model_name: file.name,
                    classes: classesInput.value.split(",").map((c) => c.trim()),
                };

                const CHUNK_SIZE = 512 * 1024; // 512KB
                
                // Check if we need chunked upload
                if (file.size > CHUNK_SIZE) {
                    // Chunked upload for large files
                    let offset = 0;
                    const totalSize = file.size;
                    
                    const uploadChunk = async () => {
                        const chunk = file.slice(offset, offset + CHUNK_SIZE);
                        const formData = new FormData();
                        formData.append("model_file", chunk);
                        formData.append("offset", offset.toString());
                        formData.append("size", totalSize.toString());
                        
                        // Include model_info only in the final chunk
                        if (offset + CHUNK_SIZE >= totalSize) {
                            formData.append("model_info", JSON.stringify(info));
                        }
                        
                        try {
                            const response = await fetch(`http://${host}:${port}/api/deviceMgr/uploadModel`, {
                                method: "POST",
                                body: formData,
                            });
                            const result = await response.text();
                            console.log(`Chunk uploaded: ${offset} / ${totalSize} (${((offset / totalSize) * 100).toFixed(1)}%)`);
                            
                            offset += CHUNK_SIZE;
                            if (offset < totalSize) {
                                // Upload next chunk
                                await uploadChunk();
                            } else {
                                console.log("Upload completed:", result);
                            }
                        } catch (error) {
                            console.log("Upload error:", error);
                        }
                    };
                    
                    uploadChunk();
                } else {
                    // Legacy single upload for small files
                    const formData = new FormData();
                    formData.append("model_file", file);
                    formData.append("model_info", JSON.stringify(info));

                    fetch(`http://${host}:${port}/api/deviceMgr/uploadModel`, {
                        method: "POST",
                        body: formData,
                    })
                        .then((response) => response.text())
                        .then((result) => console.log(result))
                        .catch((error) => console.log("error", error));
                }
            } else if (node.modelInfo || node.infoChanged) {
                const info = JSON.parse(node.modelInfo);
                info.classes = classesInput.value.split(",").map((c) => c.trim());
                
                const CHUNK_SIZE = 512 * 1024; // 512KB
                
                if (node.modelFile && node.modelFile.size > CHUNK_SIZE) {
                    // Chunked upload for large model files
                    const file = node.modelFile;
                    let offset = 0;
                    const totalSize = file.size;
                    
                    const uploadChunk = async () => {
                        const chunk = file.slice(offset, offset + CHUNK_SIZE);
                        const formData = new FormData();
                        formData.append("model_file", chunk);
                        formData.append("offset", offset.toString());
                        formData.append("size", totalSize.toString());
                        
                        // Include model_info only in the final chunk
                        if (offset + CHUNK_SIZE >= totalSize) {
                            formData.append("model_info", JSON.stringify(info));
                        }
                        
                        try {
                            const response = await fetch(`http://${host}:${port}/api/deviceMgr/uploadModel`, {
                                method: "POST",
                                body: formData,
                            });
                            const result = await response.text();
                            console.log(`Chunk uploaded: ${offset} / ${totalSize} (${((offset / totalSize) * 100).toFixed(1)}%)`);
                            
                            offset += CHUNK_SIZE;
                            if (offset < totalSize) {
                                // Upload next chunk
                                await uploadChunk();
                            } else {
                                console.log("Upload completed:", result);
                                node.modelFile = null;
                            }
                        } catch (error) {
                            console.log("Upload error:", error);
                        }
                    };
                    
                    uploadChunk();
                } else {
                    // Legacy single upload for small files or info-only updates
                    const formData = new FormData();
                    if (node.modelFile) {
                        formData.append("model_file", node.modelFile);
                        node.modelFile = null;
                    }
                    formData.append("model_info", JSON.stringify(info));
                    fetch(`http://${host}:${port}/api/deviceMgr/uploadModel`, {
                        method: "POST",
                        body: formData,
                    })
                        .then((response) => response.text())
                        .then((result) => console.log(result))
                        .catch((error) => console.log("error", error));
                }
            }
        },
    });

    RED.events.on("nodes:add", function (node) {
        const existingNodes = RED.nodes.filterNodes({ type: "model" });
        if (existingNodes.length > 1) {
            RED.notify("This node can only be instantiated once.", "error");
            RED.nodes.remove(node.id);
        }
    });
</script>
<script type="text/markdown" data-help-name="model">
This is the `model node` for Seeed SenseCraft Model Assistant such as reCamera or Pi camera.

#### Supported Model

Freely change models like yolo v5, yolo v8, yolo 11 and so on. You can also enjoy the models from SenseCraft to find the perfect fit for you. If you would like to convert your own model to cviformat for reCamera, please visit our [Wiki instruction](https://wiki.seeedstudio.com/recamera_model_conversion/).

### Inputs

-   **payload (`buffer`)**: Input from the `camera` node

### Parameters

-   **Base64 Image Output Checkbox**: This checkbox is used to determine whether the base64 image code should be output along with other parameters. **Warning: Enabling this option may significantly increase system load and network bandwidth usage. Use with caution in production environments.**
-   **Trace Checkbox**: Enables the tracking mode. When enabled, each detected object will be assigned a unique ID.
-   **Counting Checkbox**: Enables the counting mode. When enabled, the node will output counting information to the console.
-   **Splitter Field**: Used to set the counting line. Draw a line within the box to count the number of objects crossing it.

### Output Example

Wire the model node to a debug node to view the output. Here is an example output for the Yolo 11n model:

```json
{
    "boxes": [
    "0": "box_center_x",
    "1": "box_center_y",
    "2": "box_width",
    "3": "box_height",
    "4": "detected object score",
    "5": "detected object class ID"
    ],
    "count": "//inference numbers",
    "image": "//base64 image code",
    "labels": [
    "0": "class name // e.g. person"
    ],
    "perf": [
    "0": "0 ms //pre-processing time",
    "1": "40 ms //inference time",
    "2": "20 ms //post-processing time"
    ],
    "resolution": [
    "0": 640,
    "1": 640
    ]
}
```
</script>
